# はじめに
このリポジトリは[手を動かしてわかるクリーンアーキテクチャ ヘキサゴナルアーキテクチャによるクリーンなアプリケーション開発](https://book.impress.co.jp/books/1123101096)を勉強した結果を残すものです  
自分なりの理解をpythonで実装していきます

# 依存関係の逆転
![](./images/クリーンアーキテクチャの概念.PNG)  
上図のようにデータベースなどの下位モジュールは中心のドメインに依存する形で存在する  
本来は上位モジュールであるドメインが下位モジュールを使用するが、インターフェース等を挟むことにより依存関係が逆転している  
詳しくは[依存関係逆転の原則について勉強してみた](https://qiita.com/maru3745/items/0e09365c9848f849de4f)の記事を参考にしてください  
しかし、ORMを使うとなるとドメインと永続化層が同じエンティティを持つ必要性がある(永続化層のエンティティをドメインに持ってこれないから)  
## ヘキサゴナルアーキテクチャ
![](./images/ヘキサゴナルアーキテクチャ.PNG)  
*上記はポート&アダプタとも呼ばれる
- アダプタ: アプリケーションの核とコミュケーションを取る
- ポート: アプリケーションとアダプタのインターフェース。アダプタがどのようにアプリケーションとコミュケーションを取るかをつかさどる
- ビジネスロジックはユースケースを実現するクラスやエンティティに実装される

ビジネスロジックを永続化層特有の問題やUI特有の問題から切り離すことによって、**変更する理由を少なくする**  
つまりは、**保守をより簡単に行える**ということにも繋がる  

# パッケージ構成戦略
## 層を意識した構成
![](./images/層を意識したパッケージ構成.PNG)  
フォルダをそのまま層の単位にしたパッケージ構成  
依存関係の逆転の原則は遵守できるが、以下のような問題が出てくる(図の赤字の部分)  
### 問題
- 機能が増えると各フォルダに各クラスが必要になり、クラスが増殖する
- ファイル名だけ見てもどのようなユースケースがあるかが分からない(ファイルの中身を確認する必要あり)  

## 機能を意識したパッケージ構成
![](./images/機能を意識したパッケージ構成.PNG)  
口座(account)に関するフォルダを切る  
口座に関する部分をフォルダに集める  
また、AccountServiceとなっていた部分をSendMonrySeriveとすることでコードを見なくても、「送金」に関わるクラスであると判断することができる  
同じパッケージでしか使用しないクラスを**プライベートパッケージ**とすることでパッケージ外からのアクセスを禁止して、関連のない機能が間違って依存することを抑制することができる  
### 問題
- パッケージを見ても何のアーキテクチャを採用しているか分からない
- 層を意識した構成に比べると依存関係の逆転原則が遵守しずらい

## アーキテクチャを意識したパッケージ構成
今回のポート&アダプタアーキテクチャをきちんと確認すると、パッケージ構成は以下のようになる  
![](./images/ドメインサービスを用いたヘキサゴナルアーキテクチャ.PNG)  
  
![](./images/アーキテクチャを意識したパッケージ構成.PNG)  

- DBを変更したい際はadaptorの部分を別に切り替えるだけでよく、portは関係しない
- portは外部とコミュケーションを取るインターフェースであるため、アプリケーションのコアとして扱うことができ、domainと同じ階層にいる。依存関係の逆転原則を実装するためにadaptorがportに依存する形になっている
- commonは全体で使用する関数とかを格納する
- アーキテクチャとパッケージ構成を同じにすることで、どのパッケージにどのコードがあるかが分かるようになる
- adaptorはportを介して呼ばれる場合を除くと外部から呼ばれることはないので、プライベートパッケージでも問題ない
- portのインターフェースはadaptorから呼ばれるためpublic宣言が必要
- プロジェクトにあう確実なパッケージ構成を見つけるのは難しいが、アーキテクチャとコードの乖離を少なくすことはできる